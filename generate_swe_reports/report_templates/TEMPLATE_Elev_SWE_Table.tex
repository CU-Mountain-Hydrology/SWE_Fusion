\setlength{\tabcolsep}{2pt}
\renewcommand{\arraystretch}{1.2}
\setlength{\extrarowheight}{0pt}
\setlength{\aboverulesep}{0pt}
\setlength{\belowrulesep}{0pt}
\fontsize{10}{12}\selectfont

{# These groups should have 2-row headers (group title on top, dates below) #}
{% set date_groups = ["% of Average", "SWE (in)", "Pillows", "Surveys", "SNODAS* (in)"] %}

{# Flatten header columns in order (everything after Basin) #}
{% set flat_cols = [] %}
{% for group, subcols in headers.items() %}
  {% for sub in subcols %}
    {% set _ = flat_cols.append({"group": group, "sub": sub}) %}
  {% endfor %}
{% endfor %}

{# Total columns = Basin + flattened cols #}
{% set total_cols = 1 + flat_cols|length %}

% DEBUG: {{ headers }}

\begin{longtable}{@{}p{2.6cm}{% for _ in range(flat_cols|length) %}c{% endfor %}}
    \toprule
    \multicolumn{ {{ total_cols }} }{c}{\large{ {{ title }} SWE Report for {{ date[4:6]|int }}/{{ date[6:8]|int }}/{{ date[0:4] }} }} \\
    \specialrule{0.3pt}{0pt}{0pt}

    {# ============================================================
       HEADER ROW 1 (TOP)
       Basin is blank on top row.
       For each group:
         - if it's a date group: show group name spanning its N subcolumns
         - otherwise: blank spanning its N subcolumns
       ============================================================ #}

    {# Basin top header cell blank #}
    ~

    {% set seen_groups = [] %}
    {% for group, subcols in headers.items() %}
        {% set g_clean = (group|string).strip() %}
        {% set span = subcols|length %}

        {# Emit one cell per group, spanning its subcolumns #}
        &
        {% if g_clean in date_groups %}
            \multicolumn{ {{ span }} }{c}{ {{ g_clean | replace('%','\\%') }} }
        {% else %}
            {% if span == 1 %}
                ~
            {% else %}
                \multicolumn{ {{ span }} }{c}{~}
            {% endif %}
        {% endif %}
    {% endfor %}
    \\

    {# ============================================================
       CMIDRULES under date-style groups only
       We compute the column ranges dynamically.
       Column indexing:
         1 = Basin
         2 = first column after Basin
       ============================================================ #}

    {% set curcol = namespace(c=2) %}
    {% for group, subcols in headers.items() %}
        {% set g_clean = (group|string).strip() %}
        {% set span = subcols|length %}

        {% if g_clean in date_groups %}
            \cmidrule(lr){ {{ curcol.c }}-{{ curcol.c + span - 1 }} }
        {% endif %}

        {% set curcol.c = curcol.c + span %}
    {% endfor %}

    {# ============================================================
       HEADER ROW 2 (BOTTOM)
       Basin label + each subcolumn label in order
       ============================================================ #}
    \makecell[l]{Basin}
    {% for col in flat_cols %}
        & {{ (col["sub"]|string) | replace('%','\\%') }}
    {% endfor %}
    \\
    \midrule
    \endfirsthead


    % ===================== CONTINUED HEAD =====================
    \toprule
    \multicolumn{ {{ total_cols }} }{c}{\large{ {{ title }} SWE Report for {{ date[4:6]|int }}/{{ date[6:8]|int }}/{{ date[0:4] }} }} \\
    \specialrule{0.3pt}{0pt}{0pt}

    ~
    {% for group, subcols in headers.items() %}
        {% set g_clean = (group|string).strip() %}
        {% set span = subcols|length %}
        &
        {% if g_clean in date_groups %}
            \multicolumn{ {{ span }} }{c}{ {{ g_clean | replace('%','\\%') }} }
        {% else %}
            {% if span == 1 %}
                ~
            {% else %}
                \multicolumn{ {{ span }} }{c}{~}
            {% endif %}
        {% endif %}
    {% endfor %}
    \\

    {% set curcol = namespace(c=2) %}
    {% for group, subcols in headers.items() %}
        {% set g_clean = (group|string).strip() %}
        {% set span = subcols|length %}
        {% if g_clean in date_groups %}
            \cmidrule(lr){ {{ curcol.c }}-{{ curcol.c + span - 1 }} }
        {% endif %}
        {% set curcol.c = curcol.c + span %}
    {% endfor %}

    \makecell[l]{Basin}
    {% for col in flat_cols %}
        & {{ (col["sub"]|string) | replace('%','\\%') }}
    {% endfor %}
    \\
    \midrule
    \endhead


    \midrule
    \multicolumn{ {{ total_cols }} }{l}{
        \footnotesize* This is a comparison to the SNODAS (SNOw Data Assimilation System) nationwide product from the National Weather Service.%
    } \\[-4pt]
    \multicolumn{ {{ 1 + df.shape[1]-1 }} }{p{0.95\textwidth}}{
        \footnotesize $\ddagger$ For volume totals above Shasta Lake add Upper Sac, McCloud and Pit volumes. For volume totals above Bend Bridge add Upper Sac, McCloud, Pit and Sac at Bend Bridge volumes.%
    } \\[-4pt]
    {% if aso_corrected %}
        \multicolumn{ {{ 1 + df.shape[1]-1 }} }{p{0.95\textwidth}}{
            \footnotesize \S{} Data in all ASO-collected basins have been bias-corrected using ASO data and therefore the SWE changes might not represent snowmelt/accumulation but rather an update to the SWE estimates based on airborne data.} \\
    {% endif %}
    \bottomrule
    \endfoot

    \bottomrule
    \endlastfoot


    {# ===================== DATA BODY ===================== #}
    {% set ns = namespace(current_basin="") %}
    {% for row in df.iloc[1:].itertuples(index=False) %}
        {% set basin_name = row[0] | replace('%', '\\%') | replace('_', '\\_') %}

        {% if basin_name != ns.current_basin %}
            {% if ns.current_basin != "" %}
                \specialrule{0.3pt}{4pt}{4pt}
            {% endif %}
            {% set ns.current_basin = basin_name %}

            {% set raw_name = basin_name %}
            {% if raw_name|length > 18 and (" " in raw_name) %}
                {% set mid = raw_name|length // 2 %}

                {# find last space before mid #}
                {% set left_space = raw_name.rfind(" ", 0, mid) %}
                {# find first space after mid #}
                {% set right_space = raw_name.find(" ", mid) %}

                {% if left_space != -1 %}
                    {% set split_idx = left_space %}
                {% elif right_space != -1 %}
                    {% set split_idx = right_space %}
                {% else %}
                    {% set split_idx = -1 %}
                {% endif %}

                {% if split_idx != -1 %}
                    \shortstack[l]{ {{ raw_name[:split_idx] }} \\ {{ raw_name[split_idx+1:] }} }
                {% else %}
                    {{ raw_name }}
                {% endif %}
            {% else %}
                {{ raw_name }}
            {% endif %}
        {% else %}
            \makecell[l]{}
        {% endif %}

        {% for val in row[1:] %}
            & {{ ("NA" if (val != val) else val) | replace('%', '\\%') }}
        {% endfor %}
        \\
    {% endfor %}

    \specialrule{0.3pt}{4pt}{4pt}
    \multicolumn{ {{ total_cols }} }{l}{\footnotesize* This is a comparison to the SNODAS (SNOw Data Assimilation System) nationwide product from the National Weather Service.} \\[-4pt]
    \multicolumn{ {{ 1 + df.shape[1]-1 }} }{p{0.95\textwidth}}{
        \footnotesize $\ddagger$ For volume totals above Shasta Lake add Upper Sac, McCloud and Pit volumes. For volume totals above Bend Bridge add Upper Sac, McCloud, Pit and Sac at Bend Bridge volumes.%
    } \\[-4pt]
    {% if aso_corrected %}
        \multicolumn{ {{ 1 + df.shape[1]-1 }} }{p{0.95\textwidth}}{
            \footnotesize \S{} Data in all ASO-collected basins have been bias-corrected using ASO data and therefore the SWE changes might not represent snowmelt/accumulation but rather an update to the SWE estimates based on airborne data.} \\
    {% endif %}
\end{longtable}
