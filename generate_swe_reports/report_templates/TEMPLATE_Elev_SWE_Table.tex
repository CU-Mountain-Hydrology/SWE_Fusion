\setlength{\tabcolsep}{2pt}
\renewcommand{\arraystretch}{1.2}
\setlength{\extrarowheight}{0pt}
\setlength{\aboverulesep}{0pt}
\setlength{\belowrulesep}{0pt}
\fontsize{10}{12}\selectfont

% DEBUG: Headers = {{ headers }}

{# These groups should have 2-row headers (group title on top, dates below) #}
{% set date_groups = ["% of Average", "SWE (in)", "Pillows", "SNODAS*"] %}

{# Flatten header columns in order (everything after Basin) #}
{% set flat_cols = [] %}
{% for group, subcols in headers.items() %}
  {% for sub in subcols %}
    {% set _ = flat_cols.append({"group": group, "sub": sub}) %}
  {% endfor %}
{% endfor %}

{# Total columns = Basin + flattened cols #}
{% set total_cols = 1 + flat_cols|length %}

\begin{longtable}{@{}p{3.2cm}{% for _ in range(flat_cols|length) %}c{% endfor %}}
    \toprule
    \multicolumn{ {{ total_cols }} }{c}{\large{ {{ title }} SWE Report for {{ date[4:6]|int }}/{{ date[6:8]|int }}/{{ date[0:4] }} }} \\
    \specialrule{0.3pt}{0pt}{0pt}

    {# ============================================================
       HEADER ROW 1 (TOP)
       Basin is blank on top row.
       For each group:
         - if it's a date group: show group name spanning its N subcolumns
         - otherwise: blank spanning its N subcolumns
       ============================================================ #}

    {# Basin top header cell blank #}
    ~

    {% set seen_groups = [] %}
    {% for group, subcols in headers.items() %}
        {% set g_clean = (group|string).strip() %}
        {% set span = subcols|length %}

        {# Emit one cell per group, spanning its subcolumns #}
        &
        {% if g_clean in date_groups %}
            \multicolumn{ {{ span }} }{c}{ {{ g_clean | replace('%','\\%') }} }
        {% else %}
            {% if span == 1 %}
                ~
            {% else %}
                \multicolumn{ {{ span }} }{c}{~}
            {% endif %}
        {% endif %}
    {% endfor %}
    \\

    {# ============================================================
       CMIDRULES under date-style groups only
       We compute the column ranges dynamically.
       Column indexing:
         1 = Basin
         2 = first column after Basin
       ============================================================ #}

    {% set curcol = namespace(c=2) %}
    {% for group, subcols in headers.items() %}
        {% set g_clean = (group|string).strip() %}
        {% set span = subcols|length %}

        {% if g_clean in date_groups %}
            \cmidrule(lr){ {{ curcol.c }}-{{ curcol.c + span - 1 }} }
        {% endif %}

        {% set curcol.c = curcol.c + span %}
    {% endfor %}

    {# ============================================================
       HEADER ROW 2 (BOTTOM)
       Basin label + each subcolumn label in order
       ============================================================ #}
    \makecell[l]{Basin}
    {% for col in flat_cols %}
        & {{ (col["sub"]|string) | replace('%','\\%') }}
    {% endfor %}
    \\
    \midrule
    \endfirsthead


    % ===================== CONTINUED HEAD =====================
    \toprule
    \multicolumn{ {{ total_cols }} }{c}{\large{ {{ title }} SWE Report for {{ date[4:6]|int }}/{{ date[6:8]|int }}/{{ date[0:4] }} }} \\
    \specialrule{0.3pt}{0pt}{0pt}

    ~
    {% for group, subcols in headers.items() %}
        {% set g_clean = (group|string).strip() %}
        {% set span = subcols|length %}
        &
        {% if g_clean in date_groups %}
            \multicolumn{ {{ span }} }{c}{ {{ g_clean | replace('%','\\%') }} }
        {% else %}
            {% if span == 1 %}
                ~
            {% else %}
                \multicolumn{ {{ span }} }{c}{~}
            {% endif %}
        {% endif %}
    {% endfor %}
    \\

    {% set curcol = namespace(c=2) %}
    {% for group, subcols in headers.items() %}
        {% set g_clean = (group|string).strip() %}
        {% set span = subcols|length %}
        {% if g_clean in date_groups %}
            \cmidrule(lr){ {{ curcol.c }}-{{ curcol.c + span - 1 }} }
        {% endif %}
        {% set curcol.c = curcol.c + span %}
    {% endfor %}

    \makecell[l]{Basin}
    {% for col in flat_cols %}
        & {{ (col["sub"]|string) | replace('%','\\%') }}
    {% endfor %}
    \\
    \midrule
    \endhead


    \multicolumn{ {{ total_cols }} }{l}{
        \small*Basin boundaries were derived from a combination of NRCS basins and HUC8 boundaries.%
        \hfill \textit{Continued on next page}
    } \\
    \bottomrule
    \endfoot

    \bottomrule
    \endlastfoot


    {# ===================== DATA BODY ===================== #}
    {% set ns = namespace(current_basin="") %}
    {% for row in df.iloc[1:].itertuples(index=False) %}
        {% set basin_name = row[0] | replace('%', '\\%') | replace('_', '\\_') %}

        {% if basin_name != ns.current_basin %}
            {% if ns.current_basin != "" %}
                \specialrule{0.3pt}{4pt}{4pt}
            {% endif %}
            {% set ns.current_basin = basin_name %}

            {% if basin_name|length > 22 %}
                {% set mid = (basin_name|length // 2) %}
                {% set split_idx = (
                    (basin_name.rfind('-', 0, mid) if basin_name.rfind('-', 0, mid) != -1 else
                     basin_name.rfind('\\_', 0, mid) if basin_name.rfind('\\_', 0, mid) != -1 else
                     mid)
                ) %}
                \makecell[l]{ {{ basin_name[:split_idx+1] }} \\ {{ basin_name[split_idx+1:] }} }
            {% else %}
                \makecell[l]{ {{ basin_name }} }
            {% endif %}
        {% else %}
            \makecell[l]{}
        {% endif %}

        {% for val in row[1:] %}
            & {{ ("NA" if (val != val) else val) | replace('%', '\\%') }}
        {% endfor %}
        \\[-2pt]
    {% endfor %}

    \specialrule{0.3pt}{4pt}{4pt}
    \multicolumn{ {{ total_cols }} }{l}{\small*Basin boundaries were derived from a combination of NRCS basins and HUC8 boundaries.} \\
    {% if aso_corrected %}
        \multicolumn{ {{ total_cols }} }{l}{\smallÂ§ASO-corrected.} \\
    {% endif %}
\end{longtable}
