"""
Automatically generates report maps in ArcPy using post-processed rasters.

**Usage:**
    python generate_maps.py report_type date [--figs REGEX] [--preview]

**Arguments:**
    - ``report_type``: Type of report to generate (e.g., WW)
    - ``date``: Date of report in YYYYMMDD format

**Options:**
    - ``--figs=REGEX``: Regex for figures to generate (default: all).
      Example: ``--figs=1a`` or ``--figs=1*,2a,3``
    - ``--preview``, ``-p``: Open the generated JPG maps upon completion
    - ``--verbose``, ``-v``: Enable verbose output messages
    - ``--prompt_user``, ``-u``: Prompt user before overwriting files or automatically selecting layer files
"""

#########################   These values should not need to be changed between runs, but may change depending on your
#         CONFIG        #   operating system, filepaths, and preferred output location.
#########################
# Filepath configs
template_aprx = "U:\EricG\MapTemplate\MapTemplate.aprx" # Project containing template for each figure
product_source_dir = r"U:\EricG\testing_Directory"      # Parent directory of the YYYYMMDD_RT_Report folders
output_parent_dir = "../output/"                        # Directory the figures will be exported to

# Figure configs
ww_all_figs = {"1a","1b","2a","2b","3","4","5","6"}     # List of all figure id's in the WestWide reports
ww_figs_to_layers = {                                   # Mapping of figure id's to layer id's
    "1a" : ["p8"],
    "1b" : ["anomRegion_table"],
    "2a" : ["anom0_200_msk"],
    "2b" : ["p11","huc6_anom_table_save"],
}
ww_layers_to_format = {                                 # Mapping of layer id's to file format (tif, csv, dbf)
    "p8" : "tif",
    "anomRegion_table" : "csv",
    "anom0_200_msk" : "tif",
    "p11" : "tif",
    "huc6_anom_table_save" : "dbf",
}
ww_layers_to_dirs = {                                   # Mapping of figure id's to data source directory
    "p8" : "*UseThis",
    "anomRegion_table" : "*UseAvg",
    "anom0_200_msk" : "*UseAvg",
    "p11" : "*UseAvg",
    "huc6_anom_table_save" : "*UseAvg",
}
#########################
#       END CONFIG      #
#########################

from zero_to_no_data import *
import argparse
import re # Regular Expression
import os # Operating System
import glob # OS Pattern Searching
import tempfile
import shutil
import arcpy

def interpret_figs(figs: str, report_type: str) -> list[str]:
    """
    Interprets the --figs regex flag

    :param figs: String value of the --figs flag as generated by parser.parse_args()
    :param report_type: Type of report to interpret figures for. e.g., WW
    :return: List of interpreted figure names to generate maps for
    :rtype: list[str]
    """
    # Determine list of figures based on report type
    match report_type:
        case 'WW':
            all_figs = ww_all_figs
        case _:
            raise Exception(f"Unrecognized report type: {report_type}")

    # Parse the argument passed into --figs
    patterns = figs.split(",")
    fig_list = set()

    for pattern in patterns:
        # Shortcut search when all figs are specified
        if pattern in ["all","."]:
            return sorted(all_figs)

        # Modify regular expression syntax to better support * wildcard
        regex_pattern = "^" + re.escape(pattern).replace("\\*", ".*") + "$"
        regex = re.compile(regex_pattern)

        # Match the pattern against all possible figure names
        pattern_found = False
        for fig in all_figs-fig_list:
            if regex.match(fig):
                fig_list.add(fig)
                pattern_found = True
        if not pattern_found:
            # Pattern does not match any name in all_figs
            raise Exception(f"--figs pattern {pattern} not recognized!")

    return sorted(fig_list)


def find_layer_file(date: int, layer_id: str, prompt_user = True, warn = True) -> str:
    """
    Finds the specific layer file to use

    :param date: Date of report in YYYYMMDD format
    :param layer_id: Layer ID defined in the *_figs_to_layers config e.g. "p8"
    :param prompt_user: Enable prompting the user when selecting between multiple options. Default: True
    :param warn: Enable warning messages. Default: True
    :return: Path to the layer file
    :rtype: str
    """

    # Find RT_Report directory for this date
    # TODO: may want to make this the results dir not the RT_Report dir, need to figure out what data is duplicated where
    rt_report_dir = os.path.join(product_source_dir, str(date) + "_RT_Report")

    # Find the directory containing the layer products to be used e.g. "...UseThis"
    try:
        layer_dir = glob.glob(os.path.join(rt_report_dir, ww_layers_to_dirs[layer_id]))[0]
    except IndexError:
        raise FileNotFoundError(f"No directory matching pattern '{ww_layers_to_dirs[layer_id]}' found in '{rt_report_dir}'! "
                                f"Confirm config values are set correctly.")

    # Find the layer products that contains the layer_id e.g. "p8"
    layer_files = glob.glob(os.path.join(layer_dir, f"*{layer_id}*.{ww_layers_to_format[layer_id]}"))
    if not layer_files:
        raise FileNotFoundError(f"No file matching pattern '{layer_id}' found in '{layer_dir}'!")

    layer_file = layer_files[0]
    if len(layer_files) > 1:
        # If one of the multiple layer files ends with "nulled", use it
        for file in layer_files:
            if ww_layers_to_format[layer_id] == "tif" and file.endswith("nulled.tif"):
                # TODO: option to disable selecting "...nulled.tif" by default
                layer_file = file
                if warn: print(f"find_layer_file warning: Multiple files matching pattern '{layer_id}' found in '{layer_dir}'. Using {layer_file}")
                break
        else: # If none of the layer files end with "nulled"
            if prompt_user:
                # Ask the user to select which file to use
                print(f"Multiple files matching pattern '{layer_id}' found in '{layer_dir}'.")
                for i, file in enumerate(layer_files):
                    print(f"\t{i+1}. {file}")
                while True:
                    print(f"Enter a number from 1 to {len(layer_files)}:", end=" ")
                    result = input()
                    try:
                        result = int(result)
                        if result in range(1,len(layer_files)+1): break
                    except ValueError: pass
                # TODO: option to remember this choice in the future e.g. always use the p*custom_name.tif pattern if multiple exist and no "nulled"
                layer_file = layer_files[int(result)-1]
            elif warn:
                # Use the first layer file found
                print(f"find_layer_file warning: Multiple files matching pattern '{layer_id}' found in '{layer_dir}'. Using {layer_files[0]}")

    return layer_file


def main():
    # Parse input arguments and flags, see top of file for argument usage examples
    parser = argparse.ArgumentParser()
    parser.add_argument("report_type", type=str, help="Acceptable report types: WW")
    parser.add_argument("date", type=int, help="Date to process (YYYYMMDD)")
    parser.add_argument("--figs", default="all", type=str, help="Regex pattern(s) for figure names to generate")
    parser.add_argument("-p","--preview", action="store_true", help="Preview the generated maps")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output messages")
    parser.add_argument("-u", "--prompt_user", action="store_true", help="Prompt the user before overwriting or automatically selecting files")
    args = parser.parse_args()

    # Interpret --figs flag and return a list of figure names to generate
    fig_list = interpret_figs(args.figs, args.report_type)

    # Clone the template aprx to a temporary directory
    temp_dir = tempfile.mkdtemp()
    working_aprx = os.path.join(temp_dir, "working_aprx.aprx")
    shutil.copyfile(template_aprx, working_aprx)
    aprx = arcpy.mp.ArcGISProject(working_aprx) # Open the working aprx in ArcPy
    for fig_id in fig_list:
        map = aprx.listMaps(f"*{fig_id}*")[0]
        if not map:
            raise ValueError(f"No map matching pattern '{fig_id}' found in '{working_aprx}'!")
        for layer_id in ww_figs_to_layers.get(fig_id): # TODO generalize ww
            # Find the existing undefined layer and copy its symbology
            symbology = None
            if ww_layers_to_format[layer_id] in ["tif",]:
                undefined_layer = map.listLayers(f"*{layer_id}*")[0]
                symbology = undefined_layer.symbology
                map.removeLayer(undefined_layer)
            elif ww_layers_to_format[layer_id] in ["csv","dbf"]:
                undefined_table = map.listTables(f"*{layer_id}*")[0]
                map.removeTable(undefined_table)

            # Find the new layer source
            new_layer_path = find_layer_file(args.date, layer_id, prompt_user=args.prompt_user)

            # Check if new raster contains zero-valued cells instead of NoData
            if new_layer_path.endswith(".tif") and contains_zero_value_cells(new_layer_path):
                # Remove zero-valued cells
                nulled_path = new_layer_path.split(".tif")[0] + "_nulled.tif"
                zero_to_no_data(new_layer_path, nulled_path, prompt_user=args.prompt_user, verbose=args.verbose)
                new_layer_path = nulled_path

            # Set the data source and update the symbology
            map.addDataFromPath(new_layer_path)
            if ww_layers_to_format[layer_id] in ["tif",]:
                layer = map.listLayers(f"*{layer_id}*")[0]
                layer.symbology = symbology

        # Export the layout to JPEG
        layout = aprx.listLayouts(f"*{fig_id}*")[0]
        if not layout:
            # TODO error handling
            pass
        layout.name = f"{args.date}_{args.report_type}_Fig{fig_id}"
        output_dir = os.path.join(output_parent_dir, f"{args.date}_{args.report_type}_JPEGmaps")
        os.makedirs(output_dir, exist_ok=True)
        layout.exportToJPEG(output_dir+"/"+layout.name+".jpg")

    # TODO: automatically zip the JPEGmaps folder at the end?

    # Clean up
    del aprx

if __name__ == '__main__':
    main()