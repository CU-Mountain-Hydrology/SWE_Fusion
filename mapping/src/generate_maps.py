"""
Automatically generates report maps in ArcPy using post-processed rasters.

**Usage:**
    python generate_maps.py report_type date [--figs REGEX] [--preview]

**Arguments:**
    - ``report_type``: Type of report to generate (e.g., WW)
    - ``date``: Date of report in YYYYMMDD format

**Options:**
    - ``--figs=REGEX``: Regex for figures to generate (default: all).
      Example: ``--figs=1a`` or ``--figs=1*,2a,3``
    - ``--preview``, ``-p``: Open the generated JPG maps upon completion
    - ``--verbose``, ``-v``: Enable verbose output messages
"""

#########################
#         CONFIG        #
#########################
# Filepath configs
template_aprx = "U:\EricG\MapTemplate\MapTemplate.aprx" # Project containing template for each figure
product_source_dir = r"U:\EricG\testing_Directory"      # Parent directory of the YYYYMMDD_RT_Report folders
layer_dir_pattern = "*UseThis"                          # Directory to get layers from. Could also be "*UseAvg" or some other glob pattern
output_parent_dir = "../output/"                        # Directory the figures will be exported to

# Figure configs
ww_all_figs = {"1a","1b","2a","2b","3","4","5","6"}     # List of all figure id's in the WestWide reports
ww_figs_to_layers = {                                   # Mapping of figure id's to layer id's
    "1a" : ["p8"],
}
#########################
#       END CONFIG      #
#########################

from zero_to_no_data import *
import argparse
import re # Regular Expression
import os # Operating System
import glob # OS Pattern Searching
import tempfile
import shutil
import arcpy

def interpret_figs(figs: str, report_type: str) -> list[str]:
    """
    Interprets the --figs regex flag

    :param figs: String value of the --figs flag as generated by parser.parse_args()
    :param report_type: Type of report to interpret figures for. e.g., WW
    :return: List of interpreted figure names to generate maps for
    :rtype: list[str]
    """
    # Determine list of figures based on report type
    match report_type:
        case 'WW':
            all_figs = ww_all_figs
        case _:
            raise Exception(f"Unrecognized report type: {report_type}")

    # Parse the argument passed into --figs
    patterns = figs.split(",")
    fig_list = set()

    for pattern in patterns:
        # Shortcut search when all figs are specified
        if pattern in ["all","."]:
            return sorted(all_figs)

        # Modify regular expression syntax to better support * wildcard
        regex_pattern = "^" + re.escape(pattern).replace("\\*", ".*") + "$"
        regex = re.compile(regex_pattern)

        # Match the pattern against all possible figure names
        pattern_found = False
        for fig in all_figs-fig_list:
            if regex.match(fig):
                fig_list.add(fig)
                pattern_found = True
        if not pattern_found:
            # Pattern does not match any name in all_figs
            raise Exception(f"--figs pattern {pattern} not recognized!")

    return sorted(fig_list)


def find_layer_file(date: int, layer_id: str, prompt_user = True, warn = True) -> str:
    """
    Finds the specific layer file to use

    :param date: Date of report in YYYYMMDD format
    :param layer_id: Layer ID defined in the *_figs_to_layers config e.g. "p8"
    :param prompt_user: Enable prompting the user when selecting between multiple options. Default: True
    :param warn: Enable warning messages. Default: True
    :return: Path to the layer file
    :rtype: str
    """

    # Find RT_Report directory for this date
    rt_report_dir = os.path.join(product_source_dir, str(date) + "_RT_Report")

    # Find the directory containing the layer products to be used e.g. "...UseThis"
    try:
        layer_dir = glob.glob(os.path.join(rt_report_dir, layer_dir_pattern))[0]
    except IndexError:
        raise FileNotFoundError(f"No directory matching pattern '{layer_dir_pattern}' found in '{rt_report_dir}'! "
                                f"Confirm config values are set correctly.")

    # Find the layer products that start with layer_id e.g. "p8"
    layer_files = glob.glob(os.path.join(layer_dir, layer_id + "*.tif"))
    if not layer_files:
        raise FileNotFoundError(f"No file matching pattern '{layer_id}' found in '{layer_dir}'!")

    layer_file = layer_files[0]
    if len(layer_files) > 1:
        # If one of the multiple layer files ends with "nulled", use it
        for file in layer_files:
            if file.endswith("nulled.tif"):
                # TODO: option to disable selecting "...nulled.tif" by default
                layer_file = file
                if warn: print(f"find_layer_file warning: Multiple files matching pattern '{layer_id}' found in '{layer_dir}'. Using {layer_file}")
                break
        else: # If none of the layer files end with "nulled"
            if prompt_user:
                # Ask the user to select which file to use
                print(f"Multiple files matching pattern '{layer_id}' found in '{layer_dir}'.")
                for i, file in enumerate(layer_files):
                    print(f"\t{i+1}. {file}")
                while True:
                    print(f"Enter a number from 1 to {len(layer_files)}:", end=" ")
                    result = input()
                    try:
                        result = int(result)
                        if result in range(1,len(layer_files)+1): break
                    except ValueError: pass
                # TODO: option to remember this choice in the future e.g. always use the p*custom_name.tif pattern if multiple exist and no "nulled"
                layer_file = layer_files[int(result)-1]
            elif warn:
                # Use the first layer file found
                print(f"find_layer_file warning: Multiple files matching pattern '{layer_id}' found in '{layer_dir}'. Using {layer_files[0]}")

    return layer_file


def main():
    # Parse input arguments and flags, see top of file for argument usage examples
    parser = argparse.ArgumentParser()
    parser.add_argument("report_type", type=str, help="Acceptable report types: WW")
    parser.add_argument("date", type=int, help="Date to process (YYYYMMDD)")
    parser.add_argument("--figs", default="all", type=str, help="Regex pattern(s) for figure names to generate")
    parser.add_argument("-p","--preview", action="store_true", help="Preview the generated maps")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output messages")
    parser.add_argument("-u", "--prompt_user", action="store_true", help="Prompt the user before overwriting or automatically selecting files")
    args = parser.parse_args()

    # Interpret --figs flag and return a list of figure names to generate
    fig_list = interpret_figs(args.figs, args.report_type)

    # Clone the template aprx to a temporary directory
    temp_dir = tempfile.mkdtemp()
    working_aprx = os.path.join(temp_dir, "working_aprx.aprx")
    shutil.copyfile(template_aprx, working_aprx)
    aprx = arcpy.mp.ArcGISProject(working_aprx) # Open the working aprx in ArcPy
    for fig_id in fig_list:
        fig1a_map = aprx.listMaps()[0]
        for layer_id in ww_figs_to_layers.get(fig_id):
            # Find the existing undefined layer and copy its symbology
            undefined_layer = fig1a_map.listLayers(f"{layer_id}_*")[0]
            symbology = undefined_layer.symbology
            fig1a_map.removeLayer(undefined_layer)

            # Find the new raster layer source
            new_layer_path = find_layer_file(args.date, layer_id, prompt_user=args.prompt_user)

            # Check if new raster contains zero-valued cells instead of NoData
            if contains_zero_value_cells(new_layer_path):
                # Remove zero-valued cells
                nulled_path = new_layer_path.split(".tif")[0] + "_nulled.tif"
                zero_to_no_data(new_layer_path, nulled_path, prompt_user=args.prompt_user, verbose=args.verbose)
                new_layer_path = nulled_path

            # Set the data source and update the symbology
            fig1a_map.addDataFromPath(new_layer_path)
            layer = fig1a_map.listLayers(f"{layer_id}_*")[0]
            layer.symbology = symbology

        # Export the layout to JPEG
        fig1a = aprx.listLayouts()[0]
        fig1a.name = f"{args.date}_{args.report_type}_Fig{fig_id}"
        output_dir = os.path.join(output_parent_dir, f"{args.date}_{args.report_type}_JPEGmaps")
        os.makedirs(output_dir, exist_ok=True)
        fig1a.exportToJPEG(output_dir+"/"+fig1a.name+".jpg")

    # TODO: automatically zip the JPEGmaps folder at the end?

    # Clean up
    del aprx

if __name__ == '__main__':
    main()